# OSPF (Open Shortest Path First)

**OSPF (Open Shortest Path First)** — это динамический протокол маршрутизации, который используется для обмена информацией о маршрутах в пределах одной автономной системы (**AS**). **OSPF** — это протокол внутренней маршрутизации (**IGP**), который работает на основе **алгоритма Dijkstra**для нахождения кратчайшего пути между узлами в сети.

----------

## Основные характеристики OSPF

- **Тип протокола:** **OSPF** — это протокол маршрутизации с состоянием канала (**link-state**). В отличие от **RIP**, **OSPF** отправляет полные карты сети своим соседям, а не просто информацию о маршрутах. *Состояния канала (lsa) отправляют соседям только свои direct-connected сети с некой, заранее указанной метрикой и неизменно пересылают такие же сообщения от других своих соседях. Каждый маршрутизатор за счет всей этой информации знает все маршрутизаторы в сети, подключенные к ним сети и значение метрик для каждой из них.*

- **Алгоритм маршрутизации:** **OSPF** использует алгоритм поиска кратчайшего пути (**Dijkstra**), который рассчитывает наилучший маршрут до каждого узла в сети на основе информации о состоянии каналов (метрики).

- **Метрики:** **OSPF** не устанавливает отдельных требований к расчету метрики и оценки маршрутов. Его стандарт определяет стоимость каждого линка. В случае прохождения маршрута через несколько линков их стоимость суммируется. Оптимальным признается маршрут с наименьшей стоимостью. При этом принципы подсчета стоимости линка зависят от принципов, примененных конкретным производителем сетевого оборудования.

  Например, **Cisco** применяет два варианта расчета стоимости:

  - **В первом случае** стоимость линка рассчитывается как обратная величина от его скорости (1000 — для 1 Мбит, 100 — для 10 Мбит, 10 — для 100 Мбит, 1 — для 1 Гбита и т. д.). Этот вариант подойдет при условии, что все маршрутизаторы будут считать стоимость по данному алгоритму, а это требует использование только устройств **Cisco**.
  - **Второй способ** предусматривает задание стоимости администратором на основе собственного определения качества линка. Этот вариант используют в тех случаях, когда качество линка определяется не одной только его скоростью. *В том числе метрика может быть завышена для линка, на котором чаще других появляются ошибки или осуществляется тарификация трафика.* Этот способ применим в сетях, где установлены маршрутизаторы разных производителей.

- **Области (Areas)**: **OSPF** поддерживает иерархическую структуру, разбивая сеть на области (**areas**). Основная область (**area 0**) — это "*основная магистраль*", и все другие области должны быть соединены с ней.

- **Конвергенция**: **OSPF** имеет быструю конвергенцию по сравнению с **RIP**, поскольку использует т*риггерные обновления — это значит, что обновления отправляются только при изменении состояния сети*, а не через фиксированные интервалы времени.

- **Поддержка VLSM и CIDR**: **OSPF** поддерживает бесклассовую маршрутизацию и позволяет использовать различные маски подсети (**VLSM**).

---------

## Типы маршрутизаторов

- **Internal Router** (внутренний маршрутизатор): маршрутизатор, все интерфейсы которого находятся в одной области.
- **Area Border Router** (ABR, пограничный маршрутизатор области): маршрутизатор, соединяющий две или более области.
- **Autonomous System Boundary Router** (ASBR, пограничный маршрутизатор автономной системы): маршрутизатор, который подключает OSPF-сеть к внешним сетям (например, к интернету).

-----------------

## Условия "*дружбы*" двух маршрутизаторов

Чтобы между маршрутизаторами завязалась "*дружба*" (отношения смежности) должны выполниться следующие условия:

- В **OSPF** должны быть настроены одинаковые **Hello Interval** на тех маршрутизаторах, что подключены друг к другу. По умолчанию это *10 секунд* в Broadcast сетях, типа Ethernet. Это своего рода **KeepAlive** сообщения. То есть каждые 10 секунд каждый маршрутизатор отправляет Hello пакет своему соседу, чтобы сказать: “Хей, я жив”
- Одинаковыми должны быть и **Dead Interval** на них. Обычно это *4 интервала Hello — 40 секунд*. Если в течение этого времени от соседа не получено **Hello**, то он считается недоступным и начинается *ПАНИКА* процесс перестроения локальной базы данных и рассылка обновлений всем соседям
- Интерфейсы, подключенные друг к другу, должны быть в одной подсети
- **OSPF** позволяет снизить нагрузку на CPU маршрутизаторов, разделив Автономную Систему на зоны. Так вот номера зон тоже должны совпадать
- У каждого маршрутизатора, участвующего в процессе **OSPF** есть свой уникальный индентификатор — **Router ID**. Если вы о нём не позаботитесь, то маршрутизатор выберет его автоматически на основе информации о подключенных интерфейсах (выбирается высший адрес из интерфейсов, активных на момент запуска процесса **OSPF**). Но опять же у хорошего инженера всё под контролем, поэтому обычно создаётся **Loopback** интерфейс, которому присваивается адрес с маской /32 и именно он назначается **Router ID**. *Это бывает удобно при обслуживании и траблшутинге*.
- Должен совпадать размер **MTU**

--------------------

## Алгоритм работы протокола OSPF

1. **Штиль**. Состояние **OSPF — DOWN**. В это короткое мгновение в сети ничего не происходит — все молчат.

2. Поднимается ветер: маршрутизатор рассылает **Hello-пакеты** на мультикастный адрес 224.0.0.5 со всех интерфейсов, где запущен **OSPF**. TTL таких сообщений равен одному, поэтому их получат только маршрутизаторы, находящиеся в том же сегменте сети. R1 переходит в состояние **INIT**.  

   В пакеты вкладывается следующая информация:

   - Router ID
   - Hello Interval
   - Dead Interval
   - Neighbors
   - Subnet mask
   - Area ID
   - Router Priority
   - Адреса DR и BDR маршрутизаторов
   - Пароль аутентификации

   Нас интересуют пока первые четыре или точнее вообще только **Router ID** и **Neighbors**. Сообщение **Hello** от маршрутизатора R1 несёт в себе его **Router ID** и не содержит **Neighbors**, потому что у него их пока нет. После получения этого мультикастного сообщения маршрутизатор R2 добавляет R1 в свою таблицу соседей (если совпали все необходимые параметры). И отправляет на R1 уже юникастом новое сообщение **Hello**, где содержится **Router ID** этого маршрутизатора, а в списке **Neigbors** перечислены все его соседи. В числе прочих соседей в этом списке есть **Router ID** R1, то есть R2 уже считает его соседом.

3. ***Дружба***. Когда R1 получает это сообщение **Hello** от R2, он пролистывает список соседей и находит в нём свой собственный **Router ID**, он добавляет R2 в свой список соседей. Теперь R1 и R2 друг у друга во взаимных соседях — это означает, что между ними установлены отношения смежности и маршрутизатор R1 переходит в состояние **TWO WAY**. Далее происходит выбор **DR** и **BDR**, но мы не будем на этом останавливаться, хоть это и довольно важные вещи. 

4. ***Затишье перед бурей***. Далее все переходят в состояние **EXSTART**. Здесь все соседи решают между собой, кто босс. Им становится маршрутизатор с наибольшим **Router ID** — R2.

5. Когда выбран *Батька*, соседи переходят в состояние **Exchange** и обмениваются **DBD-сообщениями** **(или DD) — Data Base Description**, которые содержат описание **LSDB** **(Link State Data Base)**, мол, я знаю про вот такие подсети.
   Тут надо пояснить, что такое **LSDB**. Если перевести на русский дословно: *база данных о состоянии линков*. В изначальном состоянии маршрутизатор знает только о тех линках (интерфейсах), на которых запущен процесс **OSPF**. По ходу пьесы, каждый маршрутизатор собирает всю информацию о сети и составляет топологию. Именно она и будет являться **LSDB**, которая должна быть одинакова на всех членах зоны.
   Первым отсылает свою **DBD** маршрутизатор, выбранный главным на данном интерфейсе — 2.2.2.2. Следом за ним то же делает и 1.1.1.1.

6. Получив сообщение, маршрутизаторы R1 и R2 отправляют подтверждение о приёме **DBD (LSAck)**, а затем сравнивают новую информацию с той, что содержится у них в **LSDB** и, если есть отличия, посылают **LSR (Link State Request)** друг другу, тем самым переходя в новое состояние **LOADING**. В **LSR** они говорят — “*Я про вот эту сеть ничего не знаю. Расскажи мне подробнее*”.

7. R2, получив **LSR** от R1, высылает **LSU (Link State Update)**, которые содержат в себе **LSA (Link State Advertisement)** c детальной информацией о нужных подсетях.
   И вот, как только R1 получит последнюю порцию данных о всех подсетях и сформирует свою **LSDB**, он переходит в своё конечное состояние **FULL STATE**.
   К тому моменту, как все маршрутизаторы зоны придут к состоянию **Full State** на всех на них должна быть полностью одинаковая **LSDB** — они же одну и ту же сеть изучали. *То есть фактически это означает, что маршрутизатор знает всю вашу сеть, что, как и куда подключено.*

8. Итак, сейчас у нас все маршрутизаторы знают всё о сети, но это знание не помогает в маршрутизации.
   Следующим шагом **OSPF**, используя **алгоритм Дейкстры** (или его ещё называют **SPF — Shortest Path First**), вычисляет кратчайший маршрут до каждого маршрутизатора в зоне — он ведь знает всю топологию. В этом ему помогают метрики. Чем она ниже, тем маршрут лучше.
   А если, например, между R1 и R3 у вас модемное соединение в 56к или крайне нестабильный GPRS линк? И есть маршрут через R2 со стабильным волокном. Тогда у них будет очень высокая стоимость и **OSPF** предпочтёт более длинный, но быстрый путь.
   Найденный путь потом добавляется в таблицу маршрутизации.

*Теперь каждые 10 секунд каждый маршрутизатор будет отправлять **Hello-пакеты**, а каждые 30 минут рассылаются **LSA** — это типа данные уже считаются устаревшими, надо бы обновить, даже если изменений не было.*

В идеальном мире на этом бы и установилось равновесие. Но мы живём в мире жестоком и равнодушном, *где инженер — это итшник, а то и компьютерщик вообще*. И в этом будничном мире кипят страсти: рвут оптику, вырубают питание, мыши перегрызают ножки процессоров (или это не в этом мире?) — иными словами, топология непрестанно меняется. И чем больше сеть, тем чаще и глобальнее изменения.

Разумеется, было бы несколько странно ждать 40 секунд (**Dead Interval**) и только потом начинать перестраивать таблицу. Это было бы простительно ещё **RIP’у**, но не протоколу, который используется в огромном количестве современных сетей. Итак, как только падает какой-либо из линков (или несколько), маршрутизатор изменяет свою **LSDB** и генерирует **LSU**, присваивая ей номер больше, чем он был прежде (у каждой **LSDB** есть номер, который берётся из последнего полученного **LSA**).

Это **LSU** сообщение рассылается на мультикастовый адрес 224.0.0.5. Маршрутизаторы получившие его, проверяют номер **LSA**, содержащихся в **LSU**:

- Если номер больше, чем номер текущей **LSA** маршрутизатора — **LSDB** меняется. (Версия **LSDB** старая, информация новая)
- Если номер такой же, ничего не происходит. Этот маршрутизатор уже получил данный **LSA** по какому-то другому пути
- Если номер полученного **LSA** меньше локальной **LSDB**, это означает, что у маршрутизатора уже более актуальная информация, и он посылает новый **LSA** (на основе своей **LSDB**) отправителю прежнего.

После произведённых (или непроизведённых) действий соседу, от которого пришёл **LSU** пересылаются **LSAck** (мол, «посылку получили — всё в порядке»), а другим соседям отправляется изначальный **LSU** без изменений. На данном маршрутизаторе снова запускается алгоритм **SPF** и, при необходимости, обновляется таблица маршрутизации.
В общем, всё это происходит в целях поддержания актуальности информации на всех устройствах — ***LSDB** должна быть одинаковой у всех.*

------------

## Типы сообщений OSPF

- **Hello (Приветственное сообщение):** Используется для установления и поддержания соседских отношений (adjacency) между маршрутизаторами
- **DBD (Database Description) — описание базы данных:** Обменивается краткими описаниями топологической базы данных (**LSDB**) между маршрутизаторами, чтобы синхронизировать базы данных
- **LSR (Link State Request) — запрос состояния связи:** Маршрутизатор запрашивает у соседа конкретные **LSA (Link State Advertisement)**, если определил, что ему не хватает определённых данных
- **LSU (Link State Update) — обновление состояния связи:** Передает **LSA** между маршрутизаторами
- **LSAck (Link State Acknowledgment) — подтверждение состояния связи:** Используется для подтверждения получения **LSU**

----------

## Состояния маршрутизаторов OSPF

- **Down (Неактивное состояние):** Маршрутизатор не получил никаких **OSPF-сообщений** от соседей. Начальная стадия перед установлением соседских отношений
- **Init (Инициализация):** Маршрутизатор получил **Hello-пакет** от соседнего маршрутизатора, но сосед ещё не признал его. Это начальная фаза установления связи
- **Two-Way (Двустороннее):** Оба маршрутизатора получили **Hello-пакеты** друг от друга. На этом этапе **OSPF** решает, стоит ли продолжать формирование соседских отношений
- **ExStart (Начало обмена):** Два маршрутизатора начинают процесс обмена **DBD-сообщениями**. Они определяют, какой маршрутизатор будет мастером, а какой – ведомым для обмена информацией.
- **Exchange (Обмен):** Происходит обмен описаниями базы данных (**DBD-сообщениями**). Маршрутизаторы получают краткие описания базы данных друг друга и сравнивают их с собственной базой
- **Loading (Загрузка):** Маршрутизаторы запрашивают недостающие **LSA** с помощью **LSR** и получают их в сообщениях **LSU**
- **Full (Полное):** Маршрутизаторы завершили обмен и синхронизацию баз данных. В этом состоянии **OSPF-соседи** имеют полные соседские отношения и готовы к маршрутизации пакетов

-------------------
